import uuid

from fastapi import APIRouter, Depends, Query, status

from .. import crud
from ..db import get_db
from ..exceptions import TranscriptNotReadyError, VideoNotFoundError
from ..schemas import (
    ErrorResponse,
    Segment,
    TranscriptResponse,
    VideoInfo,
    YouTubeTranscriptResponse,
    YTSegment,
)

router = APIRouter(prefix="", tags=["Videos"])


@router.get(
    "/videos/{video_id}/transcript",
    response_model=TranscriptResponse,
    summary="Get video transcript",
    description="""
    Retrieve the Whisper-generated transcript for a video with optional speaker diarization.
    
    This endpoint returns the transcript generated by our Whisper pipeline, which includes
    speaker labels if diarization was successful.
    
    **Transcript Generation:**
    - Audio is transcribed using Whisper (faster-whisper or openai-whisper backend)
    - Optional speaker diarization using pyannote.audio
    - Segments are ordered chronologically by start time
    """,
    responses={
        200: {"description": "Transcript retrieved successfully"},
        404: {
            "description": "Video not found",
            "model": ErrorResponse,
        },
        503: {
            "description": "Transcript not ready - still processing",
            "model": ErrorResponse,
            "content": {
                "application/json": {
                    "example": {
                        "error": "transcript_not_ready",
                        "message": "Transcript for video 123e4567-e89b-12d3-a456-426614174000 is still processing",
                        "details": {"state": "processing"},
                    }
                }
            },
        },
    },
)
def get_transcript(video_id: uuid.UUID, db=Depends(get_db)):
    """Get the Whisper-generated transcript for a video."""
    # Check if video exists
    video = crud.get_video(db, video_id)
    if not video:
        raise VideoNotFoundError(str(video_id))

    segs = crud.list_segments(db, video_id)
    if not segs:
        # No segments found; inferring that the video is still processing
        raise TranscriptNotReadyError(str(video_id), "processing")

    return TranscriptResponse(
        video_id=video_id, segments=[Segment(start_ms=r[0], end_ms=r[1], text=r[2], speaker_label=r[3]) for r in segs]
    )


@router.get(
    "/videos/{video_id}",
    response_model=VideoInfo,
    summary="Get video information",
    description="""
    Retrieve basic information about a video including title, duration, and YouTube ID.
    """,
    responses={
        200: {"description": "Video information retrieved successfully"},
        404: {"description": "Video not found", "model": ErrorResponse},
    },
)
def get_video_info(video_id: uuid.UUID, db=Depends(get_db)):
    """Get basic information about a video."""
    v = crud.get_video(db, video_id)
    if not v:
        raise VideoNotFoundError(str(video_id))
    return VideoInfo(
        id=v["id"], youtube_id=v["youtube_id"], title=v.get("title"), duration_seconds=v.get("duration_seconds")
    )


@router.get(
    "/videos",
    response_model=list[VideoInfo],
    summary="List videos",
    description="""
    List all videos with pagination support.
    
    Returns videos in reverse chronological order (newest first).
    """,
    responses={
        200: {
            "description": "List of videos retrieved successfully",
            "content": {
                "application/json": {
                    "example": [
                        {
                            "id": "123e4567-e89b-12d3-a456-426614174000",
                            "youtube_id": "dQw4w9WgXcQ",
                            "title": "Example Video",
                            "duration_seconds": 212,
                        }
                    ]
                }
            },
        }
    },
)
def list_videos(
    limit: int = Query(50, ge=1, le=100, description="Maximum number of videos to return"),
    offset: int = Query(0, ge=0, description="Number of videos to skip for pagination"),
    db=Depends(get_db),
):
    """List all videos with pagination."""
    rows = crud.list_videos(db, limit=limit, offset=offset)
    return [
        VideoInfo(
            id=r["id"], youtube_id=r["youtube_id"], title=r.get("title"), duration_seconds=r.get("duration_seconds")
        )
        for r in rows
    ]


@router.get(
    "/videos/{video_id}/youtube-transcript",
    response_model=YouTubeTranscriptResponse,
    summary="Get YouTube's native captions",
    description="""
    Retrieve YouTube's native closed captions for a video.
    
    This endpoint returns the original captions provided by YouTube, either
    auto-generated (ASR) or manually created. These are separate from our
    Whisper-generated transcripts.
    
    **Caption Types:**
    - `asr`: Auto-generated by YouTube's speech recognition
    - Manual: Human-created closed captions
    """,
    responses={
        200: {"description": "YouTube transcript retrieved successfully"},
        404: {"description": "Video not found", "model": ErrorResponse},
        503: {
            "description": "YouTube transcript not available",
            "model": ErrorResponse,
        },
    },
)
def get_youtube_transcript(video_id: uuid.UUID, db=Depends(get_db)):
    """Get YouTube's native closed captions for a video."""
    # Check if video exists
    video = crud.get_video(db, video_id)
    if not video:
        raise VideoNotFoundError(str(video_id))

    yt = crud.get_youtube_transcript(db, video_id)
    if not yt:
        raise TranscriptNotReadyError(str(video_id), "no_youtube_transcript")

    segs = crud.list_youtube_segments(db, yt["id"])
    return YouTubeTranscriptResponse(
        video_id=video_id,
        language=yt.get("language"),
        kind=yt.get("kind"),
        full_text=yt.get("full_text"),
        segments=[YTSegment(start_ms=r[0], end_ms=r[1], text=r[2]) for r in segs],
    )
